\section{Design}
\label{sec:design}

\subsection{Library Operating System for Socket}

This subsection shows the architecture of \sys.

Processes as a distributed system.
Threads are treated as separate processes.
Processes communicate with each other via message passing.

For compatibility
LD\_PRELOAD.

How to remove coordination bottleneck:
Separate scalable and non-scalable parts of socket API.
Scalable parts are implemented in each process, and non-scalable parts are delegated to a monitor process.
For most socket operations, two processes communicate with each other directly, without involving the monitor process.

Subsections discuss each component in detail.


\subsection{Scaling Socket API}

Data structure in each process. Data structure in the monitor process.

Need a figure to show the lifecycle (message passing flow) of a socket connection. Three sub-figures:

\begin{itemize}
	\item Socket initialization.
	\item Connection setup.
	\item Data transmission.
\end{itemize}

\subsection{Fork and Thread Creation}


\subsection{Lockless Shared-memory Queue}

Inter-process communication through single-writer and single-reader lockless shared-memory queue. The queue is a ring buffer.

Multiplex file descriptors through a same queue to reduce memory footprint and polling cost. Why we can do this without head-of-line blocking problem? Because most applications call epoll to get events and process them one by one.


Data buffer and free slot allocation.

Head of line blocking problem implies additional features:
\begin{itemize}
	\item Fetch from middle (del).
	\item One normal queue and an emergency queue. Why we need the emergency queue.
	\item Overflow per-file-descriptor slot to prevent deadlock.
\end{itemize}




\subsection{Zero Copy Sockets}

\subsection{RDMA for Remote Access}

