\section{Architecture}
\label{sec:design}

\sys takes the idea of Library Operating System. All the threads are treated as separated processes in our design. All function calls to the GNU C library of each thread and process is hooked to our library \libipc. 

\libipc leverages message passing to communicate with other processes to conduct inter-process communication and coordination of the resources of the operating system i.e. file system, networking (sockets) in user-mode. We take advantage of the unmodified Linux Kernel for process creation and isolation, scheduling and memory management.

To make a high performance design of \libipc, we treat processes as a distributed system and separate the Linux API to scalable and non-scalable parts. For the scalable parts eg. assign file descriptor, the \libipc of each process settle them individually. For the non-scalable parts, \libipc revisit the idea of a single monitor process on each machine to tackle the coordination problem without the overhead of traditional distributed systems.

We noticed that the read and write between two processes can be highly scalable if two process communicate with each other directly with a shared memory queue. As a result, only the connection setup is coordinated by the monitor, which alleviate the workload of the monitor. The permission of Linux Kernel could provide isolation for different connections. RDMA is used in our design for inter-process communication across multiple machines.

  

This subsection shows the architecture of \sys. (Library Operating System for Socket)

Processes as a distributed system.
Threads are treated as separate processes.
Processes communicate with each other via message passing.
Shared-memory isolation.

File system, inter-process communication, network stack and storage stack in user-mode.
Use unmodified Linux kernel for process/thread creation, scheduling and memory management.

To remove coordination bottleneck:
Separate scalable and non-scalable parts of socket API.
Scalable parts are implemented in the library in each process, and non-scalable parts are delegated to a monitor process.
Monitor is like the coordinator in distributed system.
For most socket operations, two processes communicate with each other directly, without involving the monitor process.



\section{Inter-Process Socket in a Server}
\label{sec:intra-server}

\subsection{Scaling Socket API}

Data structure in each process. Data structure in the monitor process.

Need a figure to show the lifecycle (message passing flow) of a socket connection. Three sub-figures:

\begin{itemize}
	\item Socket initialization.
	\item Connection setup.
	\item Data transmission.
\end{itemize}


\subsection{Fork and Thread Creation}

Key point: Coordination in shared socket.

\subsection{Lockless Shared-memory Queue}

Inter-process communication through single-writer and single-reader lockless shared-memory queue. The queue is a ring buffer.

Multiplex file descriptors through a same queue to reduce memory footprint and polling cost. Why we can do this without head-of-line blocking problem? Because most applications call epoll to get events and process them one by one.


Head of line blocking problem implies additional features:
\begin{itemize}
	\item Fetch from middle (del).
	\item One normal queue and an emergency queue. Why we need the emergency queue.
	\item Overflow per-file-descriptor slot to prevent deadlock.
\end{itemize}

Data buffer and free slot allocation.

\subsection{Event Polling and Notification}

Discuss epoll and signal.

Message passing may wait too long.
Signal mechanism. Signal process after waiting until timeout.

Monitor detect process death (via control socket SIGHUP) and notify endpoints.


\subsection{Zero Copy}



\section{Utilizing RDMA for Inter-server Socket}
\label{sec:rdma}

