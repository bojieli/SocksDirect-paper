\subsection{Application Performance}
\label{subsec:application}

In this section, we demonstrate that \sys{} can significantly improve the performance of real-world applications without modifying the code.

\subsubsection{Nginx HTTP Server}
\quad

We use an Nginx~\cite{nginx} as reverse proxy. Request come from another host, proxied to a web service in the same host, which generates a fixed-sized HTTP response.

Figure: latency vs request size.

Figure: 1KB request throughput scalability with number of cores.

\subsubsection{Redis Key-Value Store}
\quad

Redis~\cite{redis}

Figure: line chart, y axis: throughput, lines: (intra-, inter-) x (\sys{}, libvma, Linux). x axis: number of concurrent clients.

Utility: redis-benchmark.
Key point: concurrency low: test latency, concurrency high: test throughput.

%\subsection{Real-time Stream Processing}

%Apache Flink~\cite{carbone2015apache} (need to turn off durability on disk)

%Scenario: Word Count (distributed system with one source, two mappers and one reducer)

%Metrics: Latency, throughput

\subsubsection{ZeroMQ Message Queue}
\quad

Figure: line chart, y axis: latency, lines: (intra-, inter-) x (\sys{}, libvma, Linux), x axis: msg size.

Utility: zeromq official test zeromq\_lat.
Key point: latency is low.

\subsubsection{Network Function Chain}
\quad

Each network function is a process that inputs from stdin and outputs to stdout. Standard pcap packet format. use \emph{pipe} to connect. Compare with Linux pipe and state-of-the-art. Figure~\ref{fig:eval-tun-tput}
Key point: intra-host is important.

\subsubsection{GraphX on Spark}
\quad

Two nodes run distributed PageRank.
Test elapsed time per iteration with \sys{}, libvma and Linux. (Only need three numbers, no figure.)