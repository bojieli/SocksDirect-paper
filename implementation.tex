\section{Implementation}
\label{sec:implementation}

For implementation, \libipc is divided to two parts: monitor and userspace library. Both part are implemented in C/CPP with total 5000 lines of code. We take advantage of templates of CPP for different types of queues in our design. Specifically, we have two techniques to highlight:
\subsection{Seamless system call hook}
\label{subsec:syscall-hook}
In order to support existing applications seamlessly, \libipc leverages \textit{LD\_PRELOAD} environment variable in Linux to load a shared library to applications, which replace the function of GNU LibC which are the wrappers of the system call. 

In our system, we use the range of file descriptor number to identify whether the system call should be hook to \libipc to avoid problems related to file descriptors not related to socket.


\textbf{
Separate file descriptors in \sys and Linux. Linux use low FD space, \sys use high FD space (what FD space). Same as LOS~\cite{huang2017high}.
}



\subsection{High performance lockless ring-buffer}
\label{subsec:lockless-queue}



\begin{itemize}
	\item requirements: Shared memory, single writer and single reader.
	\item each slot 16 bytes
	\item Figure: two pointers, several isvalid items, data buffer
	\item pointer: local
	\item label -> flag
	\item isvalid meaning
	\item isdeleted: push clear bit, pick from middle (iterate from head to tail), pop (set pointer iterate...)
	\item It is common -> cite systems with memory fence
	\item data buffer: avoid memory fragmentation, fixed sized slots, chain, queue (lockless ring buffer)
	\item mention zero copy
\end{itemize}

For our lockless queue i.e. ring buffer, each slots have a \textit{isvalid} label. Both of the sender side and the receiver side have a pointer pointed to the first slots available for write/read. As stated in section \ref{subsubsec:data_trans}, in order to enable picking the data from the middle of the queue, each slot has an additional \textit{isdeleted} label. When picked from the middle of the queue, \textit{isdeleted} is set. After the receiver pop the first item from the queue, it check the \textit{isdeleted} label and set the pointer to the next element which \textit{isdeleted} is not set and \textit{isvalid} is set.

It is common that the operation of the shared memory is protected by the \textit{memory fence} instruction in order to avoid the reorder caused by out-of-order execution on modern X86 CPU, which has expensive cost since it locks the memory bus. We make the observation that only write may be delayed according to the manual of Intel \cite{sewell2010x86,intel-manual}. By carefully adjusting the order of the instructions and removing \textit{memory fence}, the throughput of lockless queue could achieve 30M per second. 


% Inter-process communication through single-writer and single-reader lockless % shared-memory queue. The queue is a ring buffer.
% 
% Multiplex file descriptors through a same queue to reduce memory footprint and % polling cost. Why we can do this without head-of-line blocking problem? Because % most applications call epoll to get events and process them one by one.
% 

Access local storage. Use SPDK and user-mode file system (cite). How to multiplex processes in accessing a file system? (1) directory and metadata go to monitor, (2) read/write within allocated area of a file: process self, (3) append or read/write outside allocated area: handled by master process of a shared file. Monitor pre-allocate free blocks to processes (batch allocation and free).

Discuss limitations: order (linux is sequentially consistent, ours is FIFO).